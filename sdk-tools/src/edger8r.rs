// Copyright (c) 2018-2023 The MobileCoin Foundation

#![doc = include_str!("../README.md")]
#![deny(missing_docs, missing_debug_implementations, unsafe_code)]

//! Edger8r Tool Wrapper

use displaydoc::Display;
use std::{
    borrow::ToOwned,
    env,
    io::Error as IoError,
    path::{Path, PathBuf},
    process::Command,
    string::String,
};

/// Errors which can occur when working with the edger8r tool.
#[derive(Debug, Display)]
pub enum Error {
    /// There was an error running the command: {0}
    Io(IoError),
    /**
     * There was an error generating the code,
     * command:\n{0}\nstdout:\n{1}\n\nstderr:\n{2}
     */
    Generate(String, String, String),
}

impl From<IoError> for Error {
    fn from(src: IoError) -> Error {
        Error::Io(src)
    }
}

/// The kind of C files to generate with the edger8r tool.
#[derive(Copy, Clone, Debug, Eq, PartialEq, Default)]
pub enum OutputKind {
    /// Generate code for untrusted
    Untrusted,
    /// Generate code for trusted
    Trusted,
    /// Generate code for both trusted and untrusted
    #[default]
    Both,
}

/// The files generated by the edger8r tool
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Edger8rFiles {
    /// The trusted files generated. Will be empty when
    /// [`OutputKind::Untrusted`] is used.
    pub trusted: Vec<PathBuf>,
    /// The untrusted files generated. Will be empty when
    /// [`OutputKind::Trusted`] is used.
    pub untrusted: Vec<PathBuf>,
}

/// Wrapper for the edger8r tool.
///
/// The Edger8r tool ships as part of the IntelÂ® Software Guard Extensions SDK.
/// It generates edge routines by reading a user-provided Enclave Description
/// Language (EDL) file. These edge routines define the interface between the
/// untrusted application and the enclave.
///
/// See [Edger8r Tool Documentation](https://download.01.org/intel-sgx/sgx-linux/2.18/docs/Intel_SGX_Developer_Reference_Linux_2.18_Open_Source.pdf#%5B%7B%22num%22%3A84%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C94.5%2C406.5%2C0%5D)
/// for more details.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Edger8r {
    /// The path to the `sgx_edger8r` executable.
    edger8r_path: PathBuf,
    /// The output directory to generate the code files into
    out_dir: Option<PathBuf>,
    /// The path to the EDL file to generate code for.
    edl_file: PathBuf,
    /// The type of code to be generated.
    output_kind: OutputKind,
    /// The EDL search paths.
    search_paths: Vec<PathBuf>,
}

impl Edger8r {
    /// Create a new edger8r builder.
    ///
    /// # Arguments
    /// * `edl_file` - The edl file to generate C files from
    pub fn new(edl_file: impl AsRef<Path>) -> Self {
        let edl_file = edl_file.as_ref().to_owned();

        Self {
            edger8r_path: Self::edger8r_path(),
            out_dir: None,
            edl_file,
            output_kind: OutputKind::Both,
            search_paths: vec![],
        }
    }

    /// Set the type of code we should generate
    ///
    /// # Arguments
    /// * `kind` - The kind of code to generate
    pub fn output_kind(mut self, kind: OutputKind) -> Self {
        self.output_kind = kind;
        self
    }

    /// Specify the output directory
    ///
    /// # Arguments
    /// * `out_dir` - the output directory to place the generated files in.
    pub fn out_dir(mut self, out_dir: impl AsRef<Path>) -> Self {
        self.out_dir = Some(out_dir.as_ref().to_owned());
        self
    }

    /// Add a search path for edl files included by ours
    ///
    /// # Argumenst
    /// * `search_path` - A search path to look in for other edl files.
    ///     The `--search-path` argument for `sgx_edger8r`.
    pub fn search_path(&mut self, search_path: impl AsRef<Path>) -> &mut Self {
        self.search_paths.push(search_path.as_ref().to_owned());
        self
    }

    /// Generate C files using the edger8r tool
    ///
    /// # Returns:
    /// The paths to the generated files.
    pub fn generate(self) -> Result<Edger8rFiles, Error> {
        let mut command = Command::new(&self.edger8r_path);

        for path in &self.search_paths {
            command.args([
                "--search-path",
                path.as_os_str()
                    .to_str()
                    .expect("Invalid UTF-8 in EDL search path"),
            ]);
        }

        let mut dirs = vec![];
        match self.output_kind {
            OutputKind::Trusted => {
                command.arg("--trusted");
                dirs.push("--trusted-dir");
            }
            OutputKind::Untrusted => {
                command.arg("--untrusted");
                dirs.push("--untrusted-dir");
            }
            OutputKind::Both => {
                dirs.extend(["--trusted-dir", "--untrusted-dir"]);
            }
        }

        let out_dir = match self.out_dir.as_ref() {
            None => Self::default_out_dir(),
            Some(dir) => dir.clone(),
        };

        command.arg(&self.edl_file);
        for d in dirs {
            command.arg(d).arg(&out_dir);
        }

        let output = command.output()?;

        if output.status.success() {
            Ok(self.output_file_names(out_dir))
        } else {
            Err(Error::Generate(
                format!("{command:?}"),
                String::from_utf8_lossy(&output.stdout).into_owned(),
                String::from_utf8_lossy(&output.stderr).into_owned(),
            ))
        }
    }

    /// The path to the `sgx_edger8r` binary
    fn edger8r_path() -> PathBuf {
        let bin_dir = mc_sgx_core_build::sgx_bin_x64_dir();
        bin_dir.join("sgx_edger8r")
    }

    /// The default out directory to use.
    ///
    /// # Panics
    /// If the environment variable `OUT_DIR` is not set. This assumes it is
    /// being run as part of a build.rs as such it looks for the `OUT_DIR`.
    fn default_out_dir() -> PathBuf {
        let target_dir = env::var("OUT_DIR").expect(
            "`OUT_DIR` environment variable is not set. Consider using `Edger8r::out_dir()`.",
        );
        target_dir.into()
    }

    /// The files generated by the edger8r tool
    ///
    /// # Arguments
    /// * `out_dir` - The directory the generated files are created in
    /// * `suffix` - The suffix to use on the generated files. Should be one of
    ///     "_u" or "_t"
    fn generated_files(&self, out_dir: impl AsRef<Path>, suffix: impl AsRef<str>) -> Vec<PathBuf> {
        let mut output_stem = self
            .edl_file
            .file_stem()
            .expect("Corrupted EDL path")
            .to_os_string()
            .into_string()
            .expect("EDL path contains invalid UTF-8");

        output_stem.push_str(suffix.as_ref());
        let mut header = out_dir.as_ref().join(&output_stem);
        header.set_extension("h");
        let mut module = out_dir.as_ref().join(&output_stem);
        module.set_extension("c");

        vec![header, module]
    }

    fn output_file_names(&self, out_dir: impl AsRef<Path>) -> Edger8rFiles {
        let (trusted, untrusted) = match self.output_kind {
            OutputKind::Trusted => (self.generated_files(&out_dir, "_t"), vec![]),
            OutputKind::Untrusted => (vec![], self.generated_files(&out_dir, "_u")),
            OutputKind::Both => (
                self.generated_files(&out_dir, "_t"),
                self.generated_files(&out_dir, "_u"),
            ),
        };
        Edger8rFiles { trusted, untrusted }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    /// Create a temporary directory.
    ///
    /// The directory will be automatically deleted when the `TempDir`s
    /// destructor is run.
    ///
    /// # Panics
    /// When unable to create the temporary directory
    fn tempdir() -> tempfile::TempDir {
        tempfile::tempdir().expect("Failed to create temporary directory")
    }

    static EMPTY_EDL: &str = r#"
        enclave {
            trusted {
                public void nothing();
            };
        };"#;

    /// Create an [`Edger8r`] with provided edl file contents as it's input
    ///
    /// The [`Edger8r`] will have the `out_dir` set to `dir`
    ///
    /// # Arguments
    /// * `dir` - The directory to create the minimal edl file in. This will
    ///     also be used as the [`Edger8r::out_dir`].
    /// * `edl_file_name` - The file name to be used for the edl file. Should be
    ///     of the form `blah.edl`. Note that the edger8r tool will use this
    ///     file stem to name generated C files.
    /// * `edl_file_contents` - The contents to write into the edl file.
    fn edger8r_with_edl_file_contents(
        dir: impl AsRef<Path>,
        edl_file_name: impl AsRef<str>,
        edl_file_contents: impl AsRef<str>,
    ) -> Edger8r {
        let edl_file = dir.as_ref().join(edl_file_name.as_ref());
        fs::write(&edl_file, edl_file_contents.as_ref()).expect("Failed to write out EDL file");
        Edger8r::new(edl_file).out_dir(dir)
    }

    /// Create an [`Edger8r`] with a minimal ([`EMPTY_EDL`]) file as it's input
    ///
    /// The [`Edger8r`] will have the `out_dir` set to `dir`
    ///
    /// # Arguments
    /// * `dir` - The directory to create the minimal edl file in. This will
    ///     also be used as the [`Edger8r::out_dir`].
    /// * `edl_file_name` - The file name to be used for the edl file. Should be
    ///     of the form `blah.edl`. Note that the edger8r tool will use this
    ///     file stem to name generated C files.
    fn edger8r_with_minimal_edl_file(
        dir: impl AsRef<Path>,
        edl_file_name: impl AsRef<str>,
    ) -> Edger8r {
        edger8r_with_edl_file_contents(dir, edl_file_name, EMPTY_EDL)
    }

    #[test]
    fn non_existent_edl() {
        let dir = tempdir();
        let error = Edger8r::new("foo.edl")
            .out_dir(&dir)
            .generate()
            .expect_err("A non existent EDL file should cause `sgx_edger8r` to fail.");
        assert!(matches!(error, Error::Generate(_, _, _)));
    }

    #[test]
    fn edl_with_default_out_dir() {
        let dir = tempdir();

        // Setting `OUT_DIR` explicitly to mimic executing from a build script
        // see https://github.com/rust-lang/cargo/issues/879
        //
        // > currently `OUT_DIR` is only defined if a build script is defined
        let out_dir = dir.path().join("out_dir");
        env::set_var("OUT_DIR", &out_dir);

        let mut edger8r = edger8r_with_minimal_edl_file(&dir, "my.edl");
        edger8r.out_dir = None;
        let result = edger8r
            .generate()
            .expect("Failed to generate code from EDL file");

        let expected_files = Edger8rFiles {
            trusted: ["my_t.h", "my_t.c"]
                .into_iter()
                .map(|f| out_dir.join(f))
                .collect(),
            untrusted: ["my_u.h", "my_u.c"]
                .into_iter()
                .map(|f| out_dir.join(f))
                .collect(),
        };
        assert_eq!(result, expected_files);

        for f in expected_files.untrusted {
            assert!(f.exists())
        }
        for f in expected_files.trusted {
            assert!(f.exists())
        }
    }

    #[test]
    fn edl_with_user_specified_out_dir() {
        let dir = tempdir();

        let out_dir = dir.path().join("my_out_dir");
        let result = edger8r_with_minimal_edl_file(&dir, "my.edl")
            .out_dir(&out_dir)
            .generate()
            .expect("Failed to generate code from EDL file");
        let expected_files = Edger8rFiles {
            trusted: ["my_t.h", "my_t.c"]
                .into_iter()
                .map(|f| out_dir.join(f))
                .collect(),
            untrusted: ["my_u.h", "my_u.c"]
                .into_iter()
                .map(|f| out_dir.join(f))
                .collect(),
        };
        assert_eq!(result, expected_files);

        for f in expected_files.untrusted {
            assert!(f.exists())
        }
        for f in expected_files.trusted {
            assert!(f.exists())
        }
    }

    #[test]
    fn generate_only_untrusted() {
        let dir = tempdir();

        let result = edger8r_with_minimal_edl_file(&dir, "my.edl")
            .output_kind(OutputKind::Untrusted)
            .generate()
            .expect("Failed to generate code from EDL file");
        let expected_files = Edger8rFiles {
            trusted: vec![],
            untrusted: ["my_u.h", "my_u.c"]
                .into_iter()
                .map(|f| dir.path().join(f))
                .collect(),
        };
        assert_eq!(result, expected_files);

        for f in expected_files.untrusted {
            assert!(f.exists())
        }

        for f in ["my_t.h", "my_t.c"] {
            let file = dir.path().join(f);
            assert!(!file.exists())
        }
    }

    #[test]
    fn generate_only_trusted() {
        let dir = tempdir();

        let result = edger8r_with_minimal_edl_file(&dir, "my.edl")
            .output_kind(OutputKind::Trusted)
            .generate()
            .expect("Failed to generate code from EDL file");
        let expected_files = Edger8rFiles {
            trusted: ["my_t.h", "my_t.c"]
                .into_iter()
                .map(|f| dir.path().join(f))
                .collect(),
            untrusted: vec![],
        };
        assert_eq!(result, expected_files);

        for f in expected_files.trusted {
            assert!(f.exists())
        }

        for f in ["my_u.h", "my_u.c"] {
            let file = dir.path().join(f);
            assert!(!file.exists())
        }
    }

    #[test]
    fn dependent_edl_in_search_paths() {
        let dir = tempdir();

        let import_1 = "other/imported.edl";
        let import_2 = "another/different.edl";
        let mut search_paths = vec![];
        for import in [import_1, import_2] {
            let import_file = dir.as_ref().join(import);
            let parent_dir = import_file
                .parent()
                .expect("Expected a parent directory for import file");
            fs::create_dir_all(parent_dir).expect("Failed to create import directory");
            search_paths.push(parent_dir.to_owned());
            fs::write(
                &import_file,
                r#"
                enclave {
                    trusted {
                        public void baz();
                        public void bar();
                    };
                };
                "#,
            )
            .expect("Failed to write import file.");
        }
        let mut edger8r = edger8r_with_edl_file_contents(
            &dir,
            "base.edl",
            r#"
            enclave {
                from "imported.edl" import baz;
                from "different.edl" import bar;
                trusted {
                    public void nothing();
                };
            };
        "#,
        );

        search_paths.into_iter().for_each(|p| {
            edger8r.search_path(&p);
        });

        let result = edger8r
            .generate()
            .expect("Failed to generate code from EDL file");
        let expected_files = Edger8rFiles {
            trusted: ["base_t.h", "base_t.c"]
                .into_iter()
                .map(|f| dir.path().join(f))
                .collect(),
            untrusted: ["base_u.h", "base_u.c"]
                .into_iter()
                .map(|f| dir.path().join(f))
                .collect(),
        };
        assert_eq!(result, expected_files);
    }
}
